from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
import uuid

games = {}

SYMBOLS = {None: "â¬›", "X": "ğŸ”´", "O": "ğŸ”µ"}

def create_board(game_id):
    game = games[game_id]
    board = game["board"]
    keyboard = []

    for i in range(3):
        row = []
        for j in range(3):
            symbol = SYMBOLS[board[i][j]]
            row.append(InlineKeyboardButton(symbol, callback_data=f"move|{game_id}|{i}|{j}"))
        keyboard.append(row)

    return InlineKeyboardMarkup(keyboard)

def new_game_button():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("ğŸ² Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯", callback_data="new_game")]
    ])

def check_winner(board):
    lines = board + list(map(list, zip(*board)))
    lines.append([board[i][i] for i in range(3)])
    lines.append([board[i][2 - i] for i in range(3)])

    for line in lines:
        if line.count(line[0]) == 3 and line[0] is not None:
            return line[0]
    return None

def is_draw(board):
    return all(cell is not None for row in board for cell in row)

async def tictactoe(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    game_id = str(uuid.uuid4())

    games[game_id] = {
        "chat_id": chat_id,
        "board": [[None] * 3 for _ in range(3)],
        "players": [],
        "turn": 0,
        "msg_id": None,
    }

    if update.message:
        msg = await update.message.reply_text(
            "ğŸ® *Ø¨Ø§Ø²ÛŒ Ø¯ÙˆØ²!*\n\nØ§ÙˆÙ„ÛŒÙ† Ú©Ø³ÛŒ Ú©Ù‡ Ú©Ù„ÛŒÚ© Ú©Ù†Ø¯ Ø¨Ø§Ø²ÛŒÚ©Ù† Ø§ÙˆÙ„ Ù…ÛŒâ€ŒØ´ÙˆØ¯.",
            reply_markup=create_board(game_id),
            parse_mode="Markdown"
        )
    elif update.callback_query:
        msg = await update.callback_query.message.reply_text(
            "ğŸ® *Ø¨Ø§Ø²ÛŒ Ø¯ÙˆØ²!*\n\nØ§ÙˆÙ„ÛŒÙ† Ú©Ø³ÛŒ Ú©Ù‡ Ú©Ù„ÛŒÚ© Ú©Ù†Ø¯ Ø¨Ø§Ø²ÛŒÚ©Ù† Ø§ÙˆÙ„ Ù…ÛŒâ€ŒØ´ÙˆØ¯.",
            reply_markup=create_board(game_id),
            parse_mode="Markdown"
        )
    else:
        return

    games[game_id]["msg_id"] = msg.message_id

async def handle_move(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data.split("|")

    if len(data) != 4:
        return

    _, game_id, i, j = data
    i, j = int(i), int(j)

    game = games.get(game_id)
    if not game:
        await query.edit_message_text("âŒ Ø¨Ø§Ø²ÛŒ Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯.")
        return

    user = query.from_user
    board = game["board"]

    if user.id not in [p["id"] for p in game["players"]]:
        if len(game["players"]) >= 2:
            await query.answer("âŒ ÙÙ‚Ø· Ø¯Ùˆ Ø¨Ø§Ø²ÛŒÚ©Ù† Ù…Ø¬Ø§Ø² Ù‡Ø³ØªÙ†Ø¯.")
            return
        symbol = "X" if len(game["players"]) == 0 else "O"
        game["players"].append({"id": user.id, "name": user.full_name, "symbol": symbol})

    if len(game["players"]) < 2:
        await query.answer("âœ… Ø´Ù…Ø§ Ø«Ø¨Øª Ø´Ø¯ÛŒØ¯! Ù…Ù†ØªØ¸Ø± Ø¨Ø§Ø²ÛŒÚ©Ù† Ø¯ÙˆÙ… Ø¨Ø§Ø´ÛŒØ¯.")
        text = f"""ğŸ® *Ø¨Ø§Ø²ÛŒ Ø¯ÙˆØ²*

Ù…Ù†ØªØ¸Ø± Ø¨Ø§Ø²ÛŒÚ©Ù† Ø¯ÙˆÙ…...

âœ… Ø¨Ø§Ø²ÛŒÚ©Ù† Ø§ÙˆÙ„: *{game['players'][0]['name']}* ({game['players'][0]['symbol']})"""
        await query.edit_message_text(text, reply_markup=create_board(game_id), parse_mode="Markdown")
        return

    if len(game["players"]) == 2 and game["turn"] == 0 and user.id == game["players"][1]["id"]:
        next_player = game["players"][game["turn"] % 2]
        text = f"""ğŸ® *Ø¨Ø§Ø²ÛŒ Ø¯ÙˆØ² Ø´Ø±ÙˆØ¹ Ø´Ø¯!*

ğŸ”´ *{game['players'][0]['name']}* vs ğŸ”µ *{game['players'][1]['name']}*
ğŸ¯ *Ù†ÙˆØ¨Øª:* _{next_player['name']} ({next_player['symbol']})_"""
        await query.edit_message_text(text, reply_markup=create_board(game_id), parse_mode="Markdown")

    current_player = game["players"][game["turn"] % 2]
    if user.id != current_player["id"]:
        await query.answer("â³ Ù†ÙˆØ¨Øª Ø¨Ø§Ø²ÛŒÚ©Ù† Ø¯ÛŒÚ¯Ø± Ø§Ø³Øª.")
        return

    if board[i][j] is not None:
        await query.answer("âš ï¸ Ø§ÛŒÙ† Ø®Ø§Ù†Ù‡ Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡.")
        return

    board[i][j] = current_player["symbol"]
    winner = check_winner(board)

    if winner:
        winner_name = current_player["name"]
        winner_emoji = SYMBOLS[winner]
        text = f"""ğŸ† *{winner_name}* {winner_emoji} Ø¨Ø±Ù†Ø¯Ù‡ Ø¨Ø§Ø²ÛŒ Ø¯ÙˆØ² Ø´Ø¯!

ğŸ”´ *{game['players'][0]['name']}* vs ğŸ”µ *{game['players'][1]['name']}*"""
        await query.edit_message_text(text, reply_markup=new_game_button(), parse_mode="Markdown")
        del games[game_id]
        return

    if is_draw(board):
        text = f"""ğŸ¤ *Ù†ØªÛŒØ­Ù‡ Ø¨Ø§Ø²ÛŒ Ø¯ÙˆØ² Ù…Ø³Ø§ÙˆÛŒ Ø´Ø¯!*

ğŸ”´ *{game['players'][0]['name']}* vs ğŸ”µ *{game['players'][1]['name']}*"""
        await query.edit_message_text(text, reply_markup=new_game_button(), parse_mode="Markdown")
        del games[game_id]
        return

    game["turn"] += 1
    next_player = game["players"][game["turn"] % 2]
    text = f"""ğŸ® *Ø¨Ø§Ø²ÛŒ Ø¯ÙˆØ²*

ğŸ”´ *{game['players'][0]['name']}* vs ğŸ”µ *{game['players'][1]['name']}*
ğŸ¯ *Ù†ÙˆØ¨Øª:* _{next_player['name']} ({next_player['symbol']})_"""
    await query.edit_message_text(text, reply_markup=create_board(game_id), parse_mode="Markdown")

# âœ… ØªØ§Ø¨Ø¹ Ø¨Ø±Ø§ÛŒ Ú©Ù„ÛŒÚ© Ø±ÙˆÛŒ "Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯"
async def handle_new_game(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    await tictactoe(update, context)
